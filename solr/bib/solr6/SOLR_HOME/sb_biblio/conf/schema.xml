<?xml version="1.0" encoding="UTF-8" ?>


<schema name="swissbib vufind bibliographic schema" version="1.6">

   <!-- If you remove this field, you must _also_ disable the update log in solrconfig.xml
      or Solr won't start. _version_ and update log are required for SolrCloud
   --> 
   <field name="_version_" type="long" indexed="true" stored="false" />
   
   <!-- points to the root document of a block of nested documents. Required for nested
      document support, may be removed otherwise
   -->
   <field name="_root_" type="string" indexed="true" stored="false" docValues="false" />

   <field name="id" type="string" indexed="true" stored="true" required="true" multiValued="false" />

    <!-- Core Fields
         *********** -->
    <!--<field name="id" type="string" indexed="true" stored="true"/> -->
    <field name="fullrecord" type="string" indexed="false" stored="true"/>
    <field name="holdings" type="string" indexed="false" stored="true"/>
    <field name="freshness" type="tdate" indexed="true" stored="false"/>

    <field name="fulltext" type="text_untreated" indexed="true" stored="true" multiValued="true" termVectors="true" termPositions="true" termOffsets="true" />
    <!-- used for loading correct record driver -->
    <field name="recordtype" type="string" indexed="false" stored="true" required="true" />
    <!-- why use the following three fields? -->
    <!--
   <field name="marc_error" type="string" indexed="false" stored="true" multiValued="true"/>
   <field name="allfields" type="text_untreated" indexed="true" stored="false"/>
   <field name="allfields_unstemmed" type="text_untreated" indexed="true" stored="false"/>
    -->
    <!--   <field name="fulltext_unstemmed" type="text_untreated" indexed="true" stored="false"/>-->
    <field name="spelling" type="textSpell" indexed="true" stored="true" multiValued="true" />
    <field name="spellingShingle" type="textSpellShingle" indexed="true" stored="true" multiValued="true" />


    <!-- Institutional Fields (and call numbers, maybe holdings later, information to access a physical or remote electronic resource)
         ******************** -->
    <field name="union" type="string" indexed="true" stored="true" multiValued="true" />
    <field name="institution" type="string" indexed="true" stored="true" multiValued="true" />
    <field name="mylibrary" type="string" indexed="true" stored="false" multiValued="true" />

    <!-- following two fields will be empty at the moment -->
    <field name="collection" type="string" indexed="true" stored="true" multiValued="true" />
    <field name="isil" type="string" stored="true" indexed="true" multiValued="true" />
    <field name="callnumber" type="callnum" indexed="true" stored="false" multiValued="true" />
    <field name="itemid" type="callnum" indexed="true" stored="false" multiValued="true" />

    <!-- Generic Fields
         ************** -->
    <field name="language" type="stringlike" indexed="true" stored="true" multiValued="true"/>
    <field name="format" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="author" type="text_untreated" indexed="true" stored="false" termVectors="true" multiValued="true" />
    <field name="title" type="text_untreated" indexed="true" stored="true" multiValued="true"/>
    <field name="title_short" type="text_untreated" indexed="true" stored="true" multiValued="true"/>
    <field name="title_sub" type="text_untreated" indexed="true" stored="false" multiValued="true"/>
    <field name="publishDate" type="int" indexed="true" stored="false" multiValued="true" />
    <field name="thumbnail" type="string" indexed="false" stored="true"/>
    <!-- vf-generic fields still missing, some for display, others for snippets/highlight and building alphabrowse, check later -->

    <!-- Catalog Specific Fields
         *********************** -->
    <field name="ctrlnum" type="isn" indexed="true" stored="false" multiValued="true" />
    <field name="isbn" type="isn" indexed="true" stored="true" multiValued="true"/>

    <field name="issn" type="isn" indexed="true" stored="true" multiValued="true"/>

    <!-- I guess it's not necessary to store FRBR-id.  todo: Clarify ramifications for grouping -->
    <field name="groupid_isn_mv" type="isn" indexed="true" stored="true" />

    <dynamicField name="*_isn_mv" type="isn" indexed="true" stored="true" multiValued="true"/>

    <field name="title_alt" type="text_untreated" indexed="true" stored="false" multiValued="true"/>
    <field name="title_old" type="text_untreated" indexed="true" stored="true" multiValued="true"/>
    <field name="title_new" type="text_untreated" indexed="true" stored="true" multiValued="true"/>
    <field name="author_additional" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="series" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="journals" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="localcode" type="stringlike" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="*_str_mv" type="string" indexed="true" stored="true" multiValued="true"/>
    <dynamicField name="*_txt_mv" type="text_untreated" indexed="true" stored="false" multiValued="true"/>
    <!--
    <field name="author-letter" type="string" indexed="true" stored="true"/>
    <field name="title_full" type="text_untreated" indexed="true" stored="true"/>
    <field name="title_full_unstemmed" type="text_untreated" indexed="true" stored="true"/>
    <field name="title_fullStr" type="string" indexed="true" stored="true"/>
    <field name="title_auth" type="text_untreated" indexed="true" stored="true"/>
    -->

    <!-- subject fields (generic field 'subfull', categories per vocabulary, classifications, special subject indexing, local subject indexing)
         **************  -->
    <field name="topic" type="text_untreated" indexed="true" stored="false" multiValued="true" termVectors="true" />
    <dynamicField name="subpers_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="subtime_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="subtitle_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="subtop_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="subgeo_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="subform_*" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="subundef" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="subgnd_enriched" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <!-- Special or local subject indexing (sources are fields 690/691) -->
    <field name="sublocal" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <field name="submusic" type="text_untreated" indexed="true" stored="false" multiValued="true" />
    <dynamicField name="classif_*" type="stringlike" indexed="true" stored="false" multiValued="true" />

    <!-- Sort Fields
         *********** -->
    <field name="author_sort" type="alphaOnlySort" indexed="true" stored="false"/>
    <field name="title_sort" type="alphaOnlySort" indexed="true" stored="false"/>
    <field name="publishDateSort" type="string" indexed="true" stored="false"/>

    <!-- Hierarchy Fields
         **************** -->
    <field name="hierarchytype" type="string" indexed="true" stored="true" multiValued="false"/>
    <field name="hierarchy_top_id" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="hierarchy_top_title" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="hierarchy_parent_id" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="hierarchy_parent_title" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="hierarchy_sequence" type="string" indexed="true" stored="true" multiValued="true"/>
    <field name="is_hierarchy_id" type="string" indexed="true" stored="true" multiValued="false"/>
    <field name="is_hierarchy_title" type="string" indexed="true" stored="true" multiValued="false"/>
    <field name="title_in_hierarchy" type="string" indexed="true" stored="true" multiValued="true" />
    <field name="hierarchy_browse" type="navFieldCombined" indexed="true" stored="false" multiValued="true"/>

    <!-- specific Facet Fields
         ********************* -->
    <dynamicField name="navAuthor_*" type="navFieldCombined" indexed="true" stored="false" multiValued="true" />
    <field name="navSubform" type="navFieldForm" multiValued="true" stored="false" />
    <dynamicField name="navSub_*" type="navFieldCombined" multiValued="true" stored="false" />
    <field name="navSubtime" type="navFieldCombined" multiValued="true" stored="false" />
    <dynamicField name="navDrsys_*" type="string" multiValued="true" indexed="true" stored="false" />
    <field name="navDrsys" type="string" multiValued="true" indexed="true" stored="false" />

    <!--  special fields
        **************** -->
    <field name="time_processed" type="tdate" stored="true" indexed="true" />
    <field name="time_indexed" type="tdate" default="NOW/MINUTE" stored="true" indexed="true" />
    <!-- mandatory field for schema version 1.5-->
    <field name="_version_" type="long" indexed="true" stored="true"/>
    <!-- Fallback-Feld zur Fehlervermeidung beim Indexierung, nicht vorhergesehenes wird nicht
         indexiert, darf aber sein -->
    <dynamicField name="*" type="text_untreated" indexed="false" stored="false" multiValued="true" />

    <!-- =================
         COPY INSTRUCTIONS
         =================
    -->
    <!-- copy to generic fields -->
    <copyField source="sub*" dest="topic" />

    <!-- COPY FIELDS FUER NAVIGATOREN / FACETTEN -->
    <!-- Facetten fuer View orange (BaBe) -->
    <copyField source="subtop_gnd" dest="navSub_orange" />
    <copyField source="subtop_idsbb" dest="navSub_orange" />
    <copyField source="subtop_mesh" dest="navSub_orange" />
    <copyField source="subpers_gnd" dest="navSub_orange" />
    <copyField source="subpers_idsbb" dest="navSub_orange" />
    <copyField source="subpers_mesh" dest="navSub_orange" />
    <copyField source="subtitle_gnd" dest="navSub_orange" />
    <copyField source="subtitle_idsbb" dest="navSub_orange" />
    <copyField source="subtitle_mesh" dest="navSub_orange" />
    <copyField source="subgeo_gnd" dest="navSub_orange" />
    <copyField source="subgeo_idsbb" dest="navSub_orange" />
    <copyField source="subgeo_mesh" dest="navSub_orange" />
    <copyField source="subtime_gnd" dest="navSub_orange" />
    <copyField source="subtime_idsbb" dest="navSub_orange" />
    <copyField source="subtime_mesh" dest="navSub_orange" />

    <copyField source="navAuthor_IDSBB" dest="navAuthor_orange" />
    <copyField source="navAuthor_SNL" dest="navAuthor_orange" />
    <copyField source="navAuthor_HAN" dest="navAuthor_orange" />

    <!-- Topic Subject Facette fuer swissbib gruen (19.03.2012/osc) -->
    <copyField source="subpers_*" dest="navSub_green" />
    <copyField source="subtitle_*" dest="navSub_green" />
    <copyField source="subtop_*" dest="navSub_green" />
    <copyField source="subgeo_*" dest="navSub_green" />

    <!-- Time Subject Facette für swissbib gruen (19.03.2012/osc) -->
    <copyField source="subtime_*" dest="navSubtime" />

    <!-- Form Facette, mit Reduktionsmechanismus -->
    <copyField source="subform_ids*" dest="navSubform" />
    <copyField source="subform_mesh" dest="navSubform" />
    <copyField source="subform_gnd" dest="navSubform" />
    <copyField source="subform_rero" dest="navSubform" />
    <copyField source="subform_sbt" dest="navSubform" />

    <!-- Facette Rechtssystematik fuer Jus-Portal (31.03.2013/tvi) -->
    <copyField source="classif_drsys_gen" dest="navDrsys" />
    <copyField source="classif_drsys_D" dest="navDrsys" />
    <copyField source="classif_drsys_F" dest="navDrsys" />
    <copyField source="classif_drsys_gen" dest="navDrsys_Gen" />
    <copyField source="classif_drsys_D" dest="navDrsys_D" />
    <copyField source="classif_drsys_E" dest="navDrsys_E" />
    <copyField source="classif_drsys_F" dest="navDrsys_F" />
    <copyField source="subgeo_*" dest="navSub_geofull" />

    <!-- copy fields for spelling -->
    <!-- ** Basic, single word spelling -->
    <copyField source="author" dest="spelling" />
    <copyField source="author_additional" dest="spelling" />
    <copyField source="title_short" dest="spelling"/>
    <copyField source="title_alt" dest="spelling" />
    <copyField source="sub*" dest="spelling"/>

    <!-- ** Complex, Shingle spelling -->
    <copyField source="author" dest="spellingShingle" />
    <copyField source="author_additional" dest="spellingShingle" />
    <copyField source="title_short" dest="spellingShingle" />
    <copyField source="title_alt" dest="spellingShingle" />
    <copyField source="sub*" dest="spellingShingle"/>
    <copyField source="series" dest="spellingShingle"/>
    <copyField source="journals" dest="spellingShingle"/>
    <!--<copyField source="add_fields" dest="spellingShingle"/>-->

    <!-- copy field for dedicated index mylibrary - also nown as favorites -->
    <copyField source="institution" dest="mylibrary" />





 <!-- Field to use to determine and enforce document uniqueness. 
      Unless this field is marked with required="false", it will be a required field
   -->
 <uniqueKey>id</uniqueKey>



    <!-- field type definitions. The "name" attribute is
       just a label to be used by field definitions.  The "class"
       attribute and any other attributes determine the real
       behavior of the fieldType.
         Class names starting with "solr" refer to java classes in a
       standard package such as org.apache.solr.analysis
    -->

    <!-- The StrField type is not analyzed, but indexed/stored verbatim.
       It supports doc values but in that case the field needs to be
       single-valued and either required or have a default value.
      -->
    <fieldType name="string" class="solr.StrField" sortMissingLast="true" />

    <!-- boolean type: "true" or "false" -->
    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true"/>


    <!--
      Default numeric field types. For faster range queries, consider the tint/tfloat/tlong/tdouble types.

      These fields support doc values, but they require the field to be
      single-valued and either be required or have a default value.
    -->
    <fieldType name="int" class="solr.TrieIntField" docValues="true" precisionStep="0" positionIncrementGap="0"/>
    <fieldType name="float" class="solr.TrieFloatField" docValues="true" precisionStep="0" positionIncrementGap="0"/>
    <fieldType name="long" class="solr.TrieLongField" docValues="true" precisionStep="0" positionIncrementGap="0"/>
    <fieldType name="double" class="solr.TrieDoubleField" docValues="true" precisionStep="0" positionIncrementGap="0"/>

    <fieldType name="tint" class="solr.TrieIntField" docValues="true" precisionStep="8" positionIncrementGap="0"/>
    <fieldType name="tfloat" class="solr.TrieFloatField" docValues="true" precisionStep="8" positionIncrementGap="0"/>
    <fieldType name="tlong" class="solr.TrieLongField" docValues="true" precisionStep="8" positionIncrementGap="0"/>
    <fieldType name="tdouble" class="solr.TrieDoubleField" docValues="true" precisionStep="8" positionIncrementGap="0"/>

    <fieldType name="date" class="solr.TrieDateField" docValues="true" precisionStep="0" positionIncrementGap="0"/>

    <!-- A Trie based date field for faster date range queries and date faceting. -->
    <fieldType name="tdate" class="solr.TrieDateField" docValues="true" precisionStep="6" positionIncrementGap="0"/>


    <!--Binary data type. The data should be sent/retrieved in as Base64 encoded Strings -->
    <fieldType name="binary" class="solr.BinaryField"/>

    <fieldType name="random" class="solr.RandomSortField" indexed="true" />


    <!--
    start swissbib solr 5.5 types
    -->
    <fieldType name="navFieldCombined" class="solr.TextField">
        <analyzer>
            <tokenizer class="solr.KeywordTokenizerFactory" />
            <filter class="solr.PatternReplaceFilterFactory"
                pattern="[Ss]\.[Nn]\.|[Aa]nonym|[\[\]*]|\[.*\]|
                         \u0022|\u003C|\u003E|\u003F|^\d{4}-\d{4}$|, \d{4}-\d{4}|
                         Formschlagwort|Aufsatzsammlung"
                replacement=""
                replace="all" />
            <filter class="solr.TrimFilterFactory" />
            <filter class="solr.LengthFilterFactory" min="2" max="100" />
        </analyzer>
    </fieldType>


    <!-- used for: Navigator form (Formschlagworte)-->
    <fieldType name="navFieldForm" class="solr.TextField">
        <analyzer>
            <tokenizer class="solr.KeywordTokenizerFactory" />
            <!-- PatternReplacements / osc -->
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="^[0A] Gesamtdarstell.*$"
                    replacement="Gesamtdarstellung"
            />
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="^Kongress \(.*\)"
                    replacement="Kongressbericht"
            />
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="^Ausstellung \(.*\)"
                    replacement="Ausstellung"
            />
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="\u003C|\u003E|\[|\]|\u0028|\u0029|Formschlagwort|Sondersammlungen"
                    replacement=""
            />
            <filter class="solr.TrimFilterFactory" />
            <!-- SynonymFilter erarbeitet mit Fachferenten Basel, Version 1.0 fertig (12.2011/osc)-->
            <filter class="solr.SynonymFilterFactory" synonyms="formsynonyms.txt" ignoreCase="true" expand="false" tokenizerFactory="solr.KeywordTokenizerFactory"/>
            <filter class="solr.LengthFilterFactory" min="2" max="60" />
        </analyzer>
    </fieldType>

    <fieldType name="text_untreated" class="solr.TextField" positionIncrementGap="100">
        <analyzer type="index">
            <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-chars.txt"/>
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.WordDelimiterFilterFactory"
                    generateWordParts="1"
                    generateNumberParts="1"
                    catenateWords="1"
                    catenateNumbers="1"
                    catenateAll="0"
                    splitOnCaseChange="1"/>
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.CJKWidthFilterFactory"/>
            <filter class="solr.CJKBigramFilterFactory"/>
            <filter class="solr.ReversedWildcardFilterFactory" />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
        <analyzer type="query">
            <charFilter class="solr.MappingCharFilterFactory" mapping="mapping-chars.txt"/>
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.WordDelimiterFilterFactory"
                    generateWordParts="1"
                    generateNumberParts="1"
                    catenateWords="0"
                    catenateNumbers="0"
                    catenateAll="0"
                    splitOnCaseChange="1"/>
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.CJKWidthFilterFactory"/>
            <filter class="solr.CJKBigramFilterFactory"/>
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
    </fieldType>


    <fieldType name="isn" class="solr.TextField" positionIncrementGap="100">
        <analyzer>
            <tokenizer class="solr.PatternTokenizerFactory" pattern="^(\S*)\s*.*$" group="1"/>
            <filter class="solr.LowerCaseFilterFactory"/>
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="^(\([a-z]+\))vtls0"
                    replacement="$10"
                    replace="all"
            />
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="[^\w]+"
                    replacement=""
                    replace="all"
            />
            <filter class="solr.TrimFilterFactory" />
            <filter class="solr.LengthFilterFactory" min="2" max="100" />
        </analyzer>
    </fieldType>


    <!-- stringlike : Feldtyp fuer Klassifikationen und Codes, lowercase und trunkierbar -->
    <fieldType name="stringlike" class="solr.TextField">
        <analyzer>
            <tokenizer class="solr.KeywordTokenizerFactory" />
            <filter class="solr.LowerCaseFilterFactory" />
            <filter class="solr.TrimFilterFactory" />
            <filter class="solr.LengthFilterFactory" min="2" max="100" />
        </analyzer>
    </fieldType>

    <!-- callnum : Feldtyp fuer Signaturen. Ev. spaeter wieder mit stringlike zusammenfuehren -->
    <fieldType name="callnum" class="solr.TextField">
        <analyzer>
            <tokenizer class="solr.KeywordTokenizerFactory" />
            <filter class="solr.LowerCaseFilterFactory" />
            <filter class="solr.PatternReplaceFilterFactory"
                    pattern="\u0020"
                    replacement=""
                    replace="all"
            />
            <filter class="solr.TrimFilterFactory" />
        </analyzer>
    </fieldType>

    <!-- text_stemmed : Feldtyp fuer Text, gestemmed, tieferes boosting -->
    <fieldType name="text_stemmed" class="solr.TextField" positionIncrementGap="100" >
        <analyzer>
            <tokenizer class="solr.WhitespaceTokenizerFactory" />
            <!--          <filter class="solr.ICUFoldingFilterFactory" />
                      <filter class="solr.LowerCaseFilterFactory" />
                          <filter class="solr.KStemFilterFactory" /> -->
            <!--       ev. koennen hier verschiedene Sprachstemmer (eng, fre, ita) sequentiell geschaltet werden??? -->
            <filter class="solr.SnowballPorterFilterFactory" language="German2" />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
        </analyzer>
    </fieldType>



    <!-- text_substringed : Feldtyp fuer Text mit n-grams fuer wildcard-searches -->
    <!--
    with Solr 4 we used the sidefront attribute which was removed with Solr5
    compare: http://stackoverflow.com/questions/28807427/edgengramfilterfactory-change-in-solr5
    side=front is now default - how to reverse this? which filter?
    -->
    <fieldType name="text_substringed" class="solr.TextField" positionIncrementGap="100" >
        <analyzer type="index">
            <tokenizer class="solr.WhitespaceTokenizerFactory" />
            <!--          <filter class="solr.ICUFoldingFilterFactory" />
                      <filter class="solr.ICUNormalizer2FilterFactory" name="nfkc" mode="decompose" />
                      <filter class="solr.LowerCaseFilterFactory" />-->
            <filter class="solr.EdgeNGramFilterFactory"
                    minGramSize="3"
                    maxGramSize="10"
            />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory" />
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.WhitespaceTokenizerFactory" />
            <!--filter class="solr.ICUFoldingFilterFactory" />
            <filter class="solr.LowerCaseFilterFactory" />-->
        </analyzer>
    </fieldType>


    <!-- Basic Text Field for use with Spell Correction
         enhanced with chain elements of old type text_spelled (14.05.2013 / osc) -->
    <fieldType name="textSpell" class="solr.TextField" positionIncrementGap="100">
        <analyzer>
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.WordDelimiterFilterFactory"
                    generateWordParts="1"
                    generateNumberParts="1"
                    catenateWords="0"
                    catenateNumbers="0"
                    catenateAll="0"
            />
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.StopFilterFactory" words="stopspellwords.txt" ignoreCase="true" />
            <filter class="solr.TrimFilterFactory" />
            <filter class="solr.LengthFilterFactory" min="3" max="50" />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
    </fieldType>

    <fieldType name="textSpellShingle" class="solr.TextField" positionIncrementGap="100">
        <analyzer type="index">
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.StopFilterFactory"
                    words="stopspellwords.txt"
                    ignoreCase="true"
            />
            <filter class="solr.ShingleFilterFactory"
                    maxShingleSize="2"
                    outputUnigrams="false"
            />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
        <analyzer type="query">
            <tokenizer class="solr.ICUTokenizerFactory"/>
            <filter class="solr.ICUFoldingFilterFactory"/>
            <filter class="solr.StopFilterFactory"
                    words="stopspellwords.txt"
                    ignoreCase="true"
            />
            <filter class="solr.ShingleFilterFactory"
                    maxShingleSize="2"
                    outputUnigrams="false"
            />
            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
        </analyzer>
    </fieldType>

    <!-- field type for sort strings -->
    <!-- old alpha sort
    <fieldType name="alphaOnlySort" docValues="true" class="solr.StrField"/>
    -->
    <!--
    <fieldType name="alphaOnlySort" docValues="true" class="solr.ICUCollationField"
               locale="de"
               strength="primary" />
      -->
    <fieldType name="alphaOnlySort"  class="solr.ICUCollationField"
               locale="de"
               strength="primary" />




    <!--

    end swissbib solr 5.5 types
    -->








    <!-- A text field that only splits on whitespace for exact matching of words -->
    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
      </analyzer>
    </fieldType>

    <!-- A text type for English text where stopwords and synonyms are managed using the REST API -->
    <fieldType name="managed_en" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.ManagedStopFilterFactory" managed="english" />
        <filter class="solr.ManagedSynonymFilterFactory" managed="english" />
      </analyzer>
    </fieldType>

    <fieldType name="text_general" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
        <!-- in this example, we will only use synonyms at query time
        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
        -->
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- A text field with defaults appropriate for English: it
         tokenizes with StandardTokenizer, removes English stop words
         (lang/stopwords_en.txt), down cases, protects words from protwords.txt, and
         finally applies Porter's stemming.  The query time analyzer
         also applies synonyms from synonyms.txt. -->
    <fieldType name="text_en" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- in this example, we will only use synonyms at query time
        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
        -->
        <!-- Case insensitive stop word removal.
        -->
        <filter class="solr.StopFilterFactory"
                ignoreCase="true"
                words="lang/stopwords_en.txt"
                />
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.EnglishPossessiveFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
        <filter class="solr.EnglishMinimalStemFilterFactory"/>
  -->
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
       <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.StopFilterFactory"
                ignoreCase="true"
                words="lang/stopwords_en.txt"
                />
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.EnglishPossessiveFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
  <!-- Optionally you may want to use this less aggressive stemmer instead of PorterStemFilterFactory:
        <filter class="solr.EnglishMinimalStemFilterFactory"/>
  -->
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
    </fieldType>

    <fieldType name="text_en_splitting" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
      <analyzer type="index">
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
        <!-- in this example, we will only use synonyms at query time
        <filter class="solr.SynonymFilterFactory" synonyms="index_synonyms.txt" ignoreCase="true" expand="false"/>
        -->
        <!-- Case insensitive stop word removal.
        -->
        <filter class="solr.StopFilterFactory"
                ignoreCase="true"
                words="lang/stopwords_en.txt"
                />
        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="1" catenateNumbers="1" catenateAll="0" splitOnCaseChange="1"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.StopFilterFactory"
                ignoreCase="true"
                words="lang/stopwords_en.txt"
                />
        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="1" generateNumberParts="1" catenateWords="0" catenateNumbers="0" catenateAll="0" splitOnCaseChange="1"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
        <filter class="solr.PorterStemFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
    <fieldType name="text_en_splitting_tight" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="true">
      <analyzer>
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_en.txt"/>
        <filter class="solr.WordDelimiterFilterFactory" generateWordParts="0" generateNumberParts="0" catenateWords="1" catenateNumbers="1" catenateAll="0"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.KeywordMarkerFilterFactory" protected="protwords.txt"/>
        <filter class="solr.EnglishMinimalStemFilterFactory"/>
        <!-- this filter can remove any duplicate tokens that appear at the same position - sometimes
             possible with WordDelimiterFilter in conjuncton with stemming. -->
        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- Just like text_general except it reverses the characters of
   each token, to enable more efficient leading wildcard queries. -->
    <fieldType name="text_general_rev" class="solr.TextField" positionIncrementGap="100">
      <analyzer type="index">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.ReversedWildcardFilterFactory" withOriginal="true"
           maxPosAsterisk="3" maxPosQuestion="2" maxFractionAsterisk="0.33"/>
      </analyzer>
      <analyzer type="query">
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt" />
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>

    <!--
    alpha only sort haben wir einen eigenen Typ
    -->
    <!--
    <fieldType name="alphaOnlySort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
      <analyzer>
        <tokenizer class="solr.KeywordTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory" />
        <filter class="solr.TrimFilterFactory" />
        <filter class="solr.PatternReplaceFilterFactory"
                pattern="([^a-z])" replacement="" replace="all"
        />
      </analyzer>
    </fieldType>
    -->
    <fieldType name="phonetic" stored="false" indexed="true" class="solr.TextField" >
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.DoubleMetaphoneFilterFactory" inject="false"/>
      </analyzer>
    </fieldType>

    <fieldType name="payloads" stored="false" indexed="true" class="solr.TextField" >
      <analyzer>
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
        <filter class="solr.DelimitedPayloadTokenFilterFactory" encoder="float"/>
      </analyzer>
    </fieldType>

    <!-- lowercases the entire field value, keeping it as a single token.  -->
    <fieldType name="lowercase" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.KeywordTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory" />
      </analyzer>
    </fieldType>

    <!-- 
      Example of using PathHierarchyTokenizerFactory at index time, so
      queries for paths match documents at that path, or in descendent paths
    -->
    <fieldType name="descendent_path" class="solr.TextField">
      <analyzer type="index">
  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
      </analyzer>
      <analyzer type="query">
  <tokenizer class="solr.KeywordTokenizerFactory" />
      </analyzer>
    </fieldType>
    <!-- 
      Example of using PathHierarchyTokenizerFactory at query time, so
      queries for paths match documents at that path, or in ancestor paths
    -->
    <fieldType name="ancestor_path" class="solr.TextField">
      <analyzer type="index">
  <tokenizer class="solr.KeywordTokenizerFactory" />
      </analyzer>
      <analyzer type="query">
  <tokenizer class="solr.PathHierarchyTokenizerFactory" delimiter="/" />
      </analyzer>
    </fieldType>

    <!-- since fields of this type are by default not stored or indexed,
         any data added to them will be ignored outright.  --> 
    <fieldType name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />

    <fieldType name="point" class="solr.PointType" dimension="2" subFieldSuffix="_d"/>

    <!-- A specialized field for geospatial search. If indexed, this fieldType must not be multivalued. -->
    <fieldType name="location" class="solr.LatLonType" subFieldSuffix="_coordinate"/>

    <!-- An alternative geospatial field type new to Solr 4.  It supports multiValued and polygon shapes.
      For more information about this and other Spatial fields new to Solr 4, see:
      http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4
    -->
    <fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType"
        geo="true" distErrPct="0.025" maxDistErr="0.001" distanceUnits="kilometers" />

    <!-- Spatial rectangle (bounding box) field. It supports most spatial predicates, and has
     special relevancy modes: score=overlapRatio|area|area2D (local-param to the query).  DocValues is recommended for
     relevancy. -->
    <fieldType name="bbox" class="solr.BBoxField"
               geo="true" distanceUnits="kilometers" numberType="_bbox_coord" />
    <fieldType name="_bbox_coord" class="solr.TrieDoubleField" precisionStep="8" docValues="true" useDocValuesAsStored="false" stored="false" />

    <fieldType name="currency" class="solr.CurrencyField" precisionStep="8" defaultCurrency="USD" currencyConfig="currency.xml" />
             


   <!-- some examples for different languages (generally ordered by ISO code) -->

    <!-- Arabic -->
    <fieldType name="text_ar" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- for any non-arabic -->
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ar.txt" />
        <!-- normalizes ﻯ to ﻱ, etc -->
        <filter class="solr.ArabicNormalizationFilterFactory"/>
        <filter class="solr.ArabicStemFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- Bulgarian -->
    <fieldType name="text_bg" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/> 
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_bg.txt" /> 
        <filter class="solr.BulgarianStemFilterFactory"/>       
      </analyzer>
    </fieldType>
    
    <!-- Catalan -->
    <fieldType name="text_ca" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- removes l', etc -->
        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ca.txt"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ca.txt" />
        <filter class="solr.SnowballPorterFilterFactory" language="Catalan"/>       
      </analyzer>
    </fieldType>
    
    <!-- CJK bigram (see text_ja for a Japanese configuration using morphological analysis) -->
    <fieldType name="text_cjk" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- normalize width before bigram, as e.g. half-width dakuten combine  -->
        <filter class="solr.CJKWidthFilterFactory"/>
        <!-- for any non-CJK -->
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.CJKBigramFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- Kurdish -->
    <fieldType name="text_ckb" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.SoraniNormalizationFilterFactory"/>
        <!-- for any latin text -->
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ckb.txt"/>
        <filter class="solr.SoraniStemFilterFactory"/>
      </analyzer>
    </fieldType>

    <!-- Czech -->
    <fieldType name="text_cz" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_cz.txt" />
        <filter class="solr.CzechStemFilterFactory"/>       
      </analyzer>
    </fieldType>
    
    <!-- Danish -->
    <fieldType name="text_da" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_da.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Danish"/>       
      </analyzer>
    </fieldType>
    
    <!-- German -->
    <fieldType name="text_de" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_de.txt" format="snowball" />
        <filter class="solr.GermanNormalizationFilterFactory"/>
        <filter class="solr.GermanLightStemFilterFactory"/>
        <!-- less aggressive: <filter class="solr.GermanMinimalStemFilterFactory"/> -->
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="German2"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Greek -->
    <fieldType name="text_el" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- greek specific lowercase for sigma -->
        <filter class="solr.GreekLowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_el.txt" />
        <filter class="solr.GreekStemFilterFactory"/>
      </analyzer>
    </fieldType>
    
    <!-- Spanish -->
    <fieldType name="text_es" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_es.txt" format="snowball" />
        <filter class="solr.SpanishLightStemFilterFactory"/>
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Spanish"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Basque -->
    <fieldType name="text_eu" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_eu.txt" />
        <filter class="solr.SnowballPorterFilterFactory" language="Basque"/>
      </analyzer>
    </fieldType>
    
    <!-- Persian -->
    <fieldType name="text_fa" class="solr.TextField" positionIncrementGap="100">
      <analyzer>
        <!-- for ZWNJ -->
        <charFilter class="solr.PersianCharFilterFactory"/>
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.ArabicNormalizationFilterFactory"/>
        <filter class="solr.PersianNormalizationFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fa.txt" />
      </analyzer>
    </fieldType>
    
    <!-- Finnish -->
    <fieldType name="text_fi" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fi.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Finnish"/>
        <!-- less aggressive: <filter class="solr.FinnishLightStemFilterFactory"/> -->
      </analyzer>
    </fieldType>
    
    <!-- French -->
    <fieldType name="text_fr" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- removes l', etc -->
        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_fr.txt"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_fr.txt" format="snowball" />
        <filter class="solr.FrenchLightStemFilterFactory"/>
        <!-- less aggressive: <filter class="solr.FrenchMinimalStemFilterFactory"/> -->
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="French"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Irish -->
    <fieldType name="text_ga" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- removes d', etc -->
        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_ga.txt"/>
        <!-- removes n-, etc. position increments is intentionally false! -->
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/hyphenations_ga.txt"/>
        <filter class="solr.IrishLowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ga.txt"/>
        <filter class="solr.SnowballPorterFilterFactory" language="Irish"/>
      </analyzer>
    </fieldType>
    
    <!-- Galician -->
    <fieldType name="text_gl" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_gl.txt" />
        <filter class="solr.GalicianStemFilterFactory"/>
        <!-- less aggressive: <filter class="solr.GalicianMinimalStemFilterFactory"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Hindi -->
    <fieldType name="text_hi" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <!-- normalizes unicode representation -->
        <filter class="solr.IndicNormalizationFilterFactory"/>
        <!-- normalizes variation in spelling -->
        <filter class="solr.HindiNormalizationFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hi.txt" />
        <filter class="solr.HindiStemFilterFactory"/>
      </analyzer>
    </fieldType>
    
    <!-- Hungarian -->
    <fieldType name="text_hu" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hu.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Hungarian"/>
        <!-- less aggressive: <filter class="solr.HungarianLightStemFilterFactory"/> -->   
      </analyzer>
    </fieldType>
    
    <!-- Armenian -->
    <fieldType name="text_hy" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_hy.txt" />
        <filter class="solr.SnowballPorterFilterFactory" language="Armenian"/>
      </analyzer>
    </fieldType>
    
    <!-- Indonesian -->
    <fieldType name="text_id" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_id.txt" />
        <!-- for a less aggressive approach (only inflectional suffixes), set stemDerivational to false -->
        <filter class="solr.IndonesianStemFilterFactory" stemDerivational="true"/>
      </analyzer>
    </fieldType>
    
    <!-- Italian -->
    <fieldType name="text_it" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <!-- removes l', etc -->
        <filter class="solr.ElisionFilterFactory" ignoreCase="true" articles="lang/contractions_it.txt"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_it.txt" format="snowball" />
        <filter class="solr.ItalianLightStemFilterFactory"/>
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Italian"/> -->
      </analyzer>
    </fieldType>
    
    <fieldType name="text_ja" class="solr.TextField" positionIncrementGap="100" autoGeneratePhraseQueries="false">
      <analyzer>
        <tokenizer class="solr.JapaneseTokenizerFactory" mode="search"/>
        <!--<tokenizer class="solr.JapaneseTokenizerFactory" mode="search" userDictionary="lang/userdict_ja.txt"/>-->
        <!-- Reduces inflected verbs and adjectives to their base/dictionary forms (辞書形) -->
        <filter class="solr.JapaneseBaseFormFilterFactory"/>
        <!-- Removes tokens with certain part-of-speech tags -->
        <filter class="solr.JapanesePartOfSpeechStopFilterFactory" tags="lang/stoptags_ja.txt" />
        <!-- Normalizes full-width romaji to half-width and half-width kana to full-width (Unicode NFKC subset) -->
        <filter class="solr.CJKWidthFilterFactory"/>
        <!-- Removes common tokens typically not useful for search, but have a negative effect on ranking -->
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ja.txt" />
        <!-- Normalizes common katakana spelling variations by removing any last long sound character (U+30FC) -->
        <filter class="solr.JapaneseKatakanaStemFilterFactory" minimumLength="4"/>
        <!-- Lower-cases romaji characters -->
        <filter class="solr.LowerCaseFilterFactory"/>
      </analyzer>
    </fieldType>
    
    <!-- Latvian -->
    <fieldType name="text_lv" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_lv.txt" />
        <filter class="solr.LatvianStemFilterFactory"/>
      </analyzer>
    </fieldType>
    
    <!-- Dutch -->
    <fieldType name="text_nl" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_nl.txt" format="snowball" />
        <filter class="solr.StemmerOverrideFilterFactory" dictionary="lang/stemdict_nl.txt" ignoreCase="false"/>
        <filter class="solr.SnowballPorterFilterFactory" language="Dutch"/>
      </analyzer>
    </fieldType>
    
    <!-- Norwegian -->
    <fieldType name="text_no" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_no.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Norwegian"/>
        <!-- less aggressive: <filter class="solr.NorwegianLightStemFilterFactory" variant="nb"/> -->
        <!-- singular/plural: <filter class="solr.NorwegianMinimalStemFilterFactory" variant="nb"/> -->
        <!-- The "light" and "minimal" stemmers support variants: nb=Bokmål, nn=Nynorsk, no=Both -->
      </analyzer>
    </fieldType>
    
    <!-- Portuguese -->
    <fieldType name="text_pt" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_pt.txt" format="snowball" />
        <filter class="solr.PortugueseLightStemFilterFactory"/>
        <!-- less aggressive: <filter class="solr.PortugueseMinimalStemFilterFactory"/> -->
        <!-- more aggressive: <filter class="solr.SnowballPorterFilterFactory" language="Portuguese"/> -->
        <!-- most aggressive: <filter class="solr.PortugueseStemFilterFactory"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Romanian -->
    <fieldType name="text_ro" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ro.txt" />
        <filter class="solr.SnowballPorterFilterFactory" language="Romanian"/>
      </analyzer>
    </fieldType>
    
    <!-- Russian -->
    <fieldType name="text_ru" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_ru.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Russian"/>
        <!-- less aggressive: <filter class="solr.RussianLightStemFilterFactory"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Swedish -->
    <fieldType name="text_sv" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_sv.txt" format="snowball" />
        <filter class="solr.SnowballPorterFilterFactory" language="Swedish"/>
        <!-- less aggressive: <filter class="solr.SwedishLightStemFilterFactory"/> -->
      </analyzer>
    </fieldType>
    
    <!-- Thai -->
    <fieldType name="text_th" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.ThaiTokenizerFactory"/>
        <filter class="solr.LowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="true" words="lang/stopwords_th.txt" />
      </analyzer>
    </fieldType>
    
    <!-- Turkish -->
    <fieldType name="text_tr" class="solr.TextField" positionIncrementGap="100">
      <analyzer> 
        <tokenizer class="solr.StandardTokenizerFactory"/>
        <filter class="solr.ApostropheFilterFactory"/>
        <filter class="solr.TurkishLowerCaseFilterFactory"/>
        <filter class="solr.StopFilterFactory" ignoreCase="false" words="lang/stopwords_tr.txt" />
        <filter class="solr.SnowballPorterFilterFactory" language="Turkish"/>
      </analyzer>
    </fieldType>

    <!-- Pre-analyzed field type, allows inserting arbitrary token streams and stored values. -->
    <fieldType name="preanalyzed" class="solr.PreAnalyzedField">
      <!-- PreAnalyzedField's builtin index analyzer just decodes the pre-analyzed token stream. -->
      <analyzer type="query">
        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
      </analyzer>
    </fieldType>


</schema>
